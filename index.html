<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X 纵向长图切割工具</title>
    <style>
        :root {
            --x-blue: #1da1f2;
            --x-dark: #15202b;
            --bg: #f7f9f9;
        }
        body { font-family: -apple-system, system-ui, sans-serif; background: var(--bg); display: flex; justify-content: center; padding: 40px 20px; }
        .card { background: white; width: 100%; max-width: 500px; padding: 25px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.05); }
        h2 { margin-top: 0; color: #0f1419; font-size: 20px; text-align: center; }
        
        /* 控制区 */
        .control-panel { background: #f0f3f4; padding: 15px; border-radius: 12px; margin-bottom: 20px; }
        .slider-group { margin-bottom: 15px; }
        .slider-group label { display: flex; justify-content: space-between; font-size: 14px; margin-bottom: 5px; color: #536471; }
        input[type="range"] { width: 100%; accent-color: var(--x-blue); }

        /* 上传区 */
        .upload-zone { border: 2px dashed #cfd9de; border-radius: 12px; padding: 40px 20px; text-align: center; cursor: pointer; transition: 0.2s; }
        .upload-zone:hover { background: #e8f5fe; border-color: var(--x-blue); }
        
        /* 预览区 */
        #preview-area { display: none; margin-top: 20px; }
        .x-mockup { background: var(--x-dark); padding: 15px; border-radius: 12px; display: flex; flex-direction: column; align-items: center; }
        #img-container { width: 100%; display: flex; flex-direction: column; }
        #img-container img { width: 100%; border-radius: 4px; }
        
        /* 按钮 */
        .btn-group { margin-top: 20px; display: grid; gap: 10px; }
        button { padding: 12px; border: none; border-radius: 25px; font-weight: bold; cursor: pointer; transition: 0.2s; font-size: 15px; }
        .btn-main { background: var(--x-blue); color: white; }
        .btn-main:hover { background: #1a91da; }
        .btn-outline { background: #eff3f4; color: #0f1419; }
    </style>
</head>
<body>

<div class="card">
    <h2>X 纵向长图切割器</h2>
    
    <div class="control-panel">
        <div class="slider-group">
            <label>切割份数 <span id="s-val">4</span></label>
            <input type="range" id="slices" min="3" max="6" value="4">
        </div>
        <div class="slider-group">
            <label>模拟 X 间隙 (px) <span id="g-val">16</span></label>
            <input type="range" id="gap" min="0" max="100" value="16">
        </div>
    </div>

    <div class="upload-zone" id="drop-zone">
        <div id="upload-prompt">
            <p style="font-weight:bold; margin:0;">点击或拖入长图</p>
            <p style="font-size:13px; color:#536471; margin:5px 0 0;">自动识别高度并分块</p>
        </div>
        <input type="file" id="file-input" accept="image/*" hidden>
    </div>

    <div id="preview-area">
        <div class="x-mockup">
            <div id="img-container"></div>
        </div>
        <div class="btn-group">
            <button class="btn-main" onclick="downloadAll()">一键下载全部切片</button>
            <button class="btn-outline" onclick="location.reload()">重新上传</button>
        </div>
    </div>
</div>

<script>
    const fileInput = document.getElementById('file-input');
    const dropZone = document.getElementById('drop-zone');
    const slicesInput = document.getElementById('slices');
    const gapInput = document.getElementById('gap');
    const imgContainer = document.getElementById('img-container');
    const previewArea = document.getElementById('preview-area');

    let sourceImg = null;

    // 仅更新 UI 数值显示（轻量操作，绑定到 input 事件）
    function updateUI() {
        document.getElementById('s-val').innerText = slicesInput.value;
        document.getElementById('g-val').innerText = gapInput.value + 'px';
        render();
    }

    // 核心渲染函数（重操作，绑定到 change 事件）
    function render() {
        imgContainer.innerHTML = '';
        const n = parseInt(slicesInput.value);
        const visualGap = parseInt(gapInput.value); // 输入值作为视觉间隙(px)
        
        // 获取参考宽度：如果预览区未显示，则使用上传区宽度
        const previewWidth = imgContainer.offsetWidth == 0 ? dropZone.offsetWidth : imgContainer.offsetWidth;
        
        // 计算源图像中需要切除的像素 (保持视觉间隙恒定)
        // 逻辑：源间隙 = 视觉间隙 * (原图宽 / 预览宽)
        // 这样无论原图分辨率多高，在预览（以及最终平台显示）时的视觉间隙都保持一致
        const sourceGap = visualGap * (sourceImg.width / previewWidth);
        
        // 计算每一块切片在原图中应占的高度
        const sliceH = (sourceImg.height - (sourceGap * (n - 1))) / n;
        
        // 设置预览图之间的间隙 (直接使用设定值)
        imgContainer.style.gap = visualGap + 'px';

        // 性能优化：限制预览图宽度，避免高分辨率卡顿
        const MAX_PREVIEW_WIDTH = 800;
        const scale = sourceImg.width > MAX_PREVIEW_WIDTH ? MAX_PREVIEW_WIDTH / sourceImg.width : 1;
        const canvasW = sourceImg.width * scale;
        const canvasH = sliceH * scale;

        for (let i = 0; i < n; i++) {
            const canvas = document.createElement('canvas');
            canvas.width = canvasW;
            canvas.height = canvasH;
            const ctx = canvas.getContext('2d');
            
            // sourceY 逻辑：起始点 + (切片高度 + 间隙) * 索引
            const sy = i * (sliceH + sourceGap);
            // 绘制时进行缩放：原图区域 -> 缩小的 Canvas 区域
            ctx.drawImage(sourceImg, 0, sy, sourceImg.width, sliceH, 0, 0, canvasW, canvasH);
            
            const img = document.createElement('img');
            img.src = canvas.toDataURL('image/png');
            imgContainer.appendChild(img);
        }
        previewArea.style.display = 'block';
        dropZone.style.display = 'none';
        
        // 保存当前的 sourceGap 供下载使用，避免 resize 导致不一致
        window.currentSourceGap = sourceGap;
    }

    // 下载逻辑：重新生成原画质切片并下载
    function downloadAll() {
        if (window.currentSourceGap === undefined) return;
        
        const n = parseInt(slicesInput.value);
        const sourceGap = window.currentSourceGap;
        const sliceH = (sourceImg.height - (sourceGap * (n - 1))) / n;

        // 创建临时画布用于生成原图切片
        const canvas = document.createElement('canvas');
        canvas.width = sourceImg.width;
        canvas.height = sliceH;
        const ctx = canvas.getContext('2d');

        for (let i = 0; i < n; i++) {
            setTimeout(() => {
                const sy = i * (sliceH + sourceGap);
                ctx.clearRect(0, 0, canvas.width, canvas.height); // 清空画布
                ctx.drawImage(sourceImg, 0, sy, sourceImg.width, sliceH, 0, 0, canvas.width, canvas.height);
                
                const a = document.createElement('a');
                a.href = canvas.toDataURL('image/png');
                a.download = `X_Split_${i+1}.png`;
                a.click();
            }, i * 300); // 间隔 300ms 依次处理
        }
    }

    // 文件监听
    fileInput.onchange = e => {
        if (e.target.files && e.target.files[0]) {
            handleFile(e.target.files[0]);
        }
    };

    // 处理文件上传
    const handleFile = (file) => {
        if (!file || !file.type.startsWith('image/')) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            sourceImg = new Image();
            sourceImg.onload = render;
            sourceImg.src = e.target.result;
        };
        reader.readAsDataURL(file);
    };

    dropZone.onclick = () => fileInput.click();
    dropZone.ondragover = (e) => { e.preventDefault(); dropZone.style.background = "#e8f5fe"; };
    dropZone.ondragleave = () => { dropZone.style.background = ""; };
    dropZone.ondrop = (e) => {
        e.preventDefault();
        dropZone.style.background = "";
        handleFile(e.dataTransfer.files[0]);
    };
    
    // 性能优化：拖动时只更新数值，松手时才渲染图片
    slicesInput.oninput = updateUI;
    gapInput.oninput = updateUI;
    
    // 初始化 UI 状态
    updateUI();
</script>
</body>
</html>