<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="title">X 纵向长图切割工具</title>
    <style>
        :root {
            --x-blue: #1da1f2;
            --x-dark: #15202b;
            --bg: #f7f9f9;
        }
        body { font-family: -apple-system, system-ui, sans-serif; background: var(--bg); display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 40px 20px; }
        .card { background: white; width: 100%; max-width: 500px; padding: 25px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.05); }
        h2 { margin-top: 0; color: #0f1419; font-size: 20px; text-align: center; }
        
        /* 模式切换 */
        .mode-switch { display: flex; background: #eff3f4; border-radius: 25px; padding: 4px; margin-bottom: 20px; }
        .mode-btn { flex: 1; border: none; background: none; padding: 10px; border-radius: 20px; cursor: pointer; font-weight: bold; color: #536471; transition: 0.2s; }
        .mode-btn.active { background: white; color: var(--x-blue); box-shadow: 0 2px 8px rgba(0,0,0,0.08); }

        /* 控制区 */
        .control-panel { background: #f0f3f4; padding: 15px; border-radius: 12px; margin-bottom: 20px; }
        .slider-group { margin-bottom: 15px; }
        .slider-group label { display: flex; justify-content: space-between; font-size: 14px; margin-bottom: 5px; color: #536471; }
        input[type="range"] { width: 100%; accent-color: var(--x-blue); }

        /* 上传区 */
        .upload-zone { border: 2px dashed #cfd9de; border-radius: 12px; padding: 40px 20px; text-align: center; cursor: pointer; transition: 0.2s; }
        .upload-zone:hover { background: #e8f5fe; border-color: var(--x-blue); }
        
        /* 预览区 */
        #preview-area, #stitch-preview-area { display: none; margin-top: 20px; }
        .x-mockup { background: var(--x-dark); padding: 15px; border-radius: 12px; display: flex; flex-direction: column; align-items: center; }
        #img-container, #stitch-img-container { width: 100%; display: flex; flex-direction: column; }
        #img-container img, #stitch-img-container img { width: 100%; border-radius: 4px; }
        
        /* 按钮 */
        .btn-group { margin-top: 20px; display: grid; gap: 10px; }
        button { padding: 12px; border: none; border-radius: 25px; font-weight: bold; cursor: pointer; transition: 0.2s; font-size: 15px; }
        .btn-main { background: var(--x-blue); color: white; }
        .btn-main:hover { background: #1a91da; }
        .btn-outline { background: #eff3f4; color: #0f1419; }
        
        /* Template buttons */
        .template-btn { flex: 1; border: 2px solid #e1e8ed; background: white; padding: 10px; border-radius: 10px; cursor: pointer; font-size: 14px; transition: 0.2s; }
        .template-btn:hover { border-color: var(--x-blue); }
        .template-btn.active { border-color: var(--x-blue); background: #e8f5fe; color: var(--x-blue); font-weight: bold; }
        
        .metadata-area { margin-top: 15px; display: none; }
        .metadata-area textarea { width: 100%; height: 80px; padding: 10px; border-radius: 8px; border: 1px solid #cfd9de; background: #f7f9f9; font-family: monospace; font-size: 12px; resize: none; box-sizing: border-box; }
        .metadata-label { font-size: 13px; color: #536471; margin-bottom: 5px; display: block; }

        /* 排序列表 */
        .sortable-list { display: flex; flex-direction: column; gap: 8px; margin-bottom: 20px; }
        .sortable-item { 
            display: flex; align-items: center; background: white; padding: 8px; 
            border-radius: 8px; border: 1px solid #e1e8ed; cursor: grab; user-select: none; transition: 0.2s;
        }
        .sortable-item:hover { border-color: var(--x-blue); }
        .sortable-item.dragging { opacity: 0.5; background: #f7f9f9; border-style: dashed; }
        .sortable-item img { width: 40px; height: 40px; object-fit: cover; border-radius: 4px; margin-right: 12px; pointer-events: none; background: #eee; }
        .sortable-item span { flex: 1; font-size: 13px; color: #536471; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }
        .sortable-icon { color: #cfd9de; margin-right: 10px; font-size: 18px; padding: 5px 10px; cursor: grab; touch-action: none; }
        
        /* 移动端优化：增加拖拽时的视觉反馈 */
        .sortable-item.touch-dragging { opacity: 0.6; background: #e8f5fe; border: 2px dashed var(--x-blue); }
        .sortable-item.touch-target { border-bottom: 2px solid var(--x-blue); }
        
        /* 语言切换 */
        .lang-switch { position: absolute; top: 15px; right: 20px; font-size: 13px; display: flex; gap: 8px; z-index: 10; }
        .lang-btn { cursor: pointer; color: #9aa8b1; text-decoration: none; padding: 2px 4px; border-radius: 4px; transition: 0.2s; }
        .lang-btn:hover { color: #536471; }
        .lang-btn.active { font-weight: bold; color: var(--x-blue); background: #e8f5fe; }
        
        .card { position: relative; background: white; width: 100%; max-width: 500px; padding: 25px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.05); }
    </style>
</head>
<body>
    <div class="lang-switch">
        <a class="lang-btn active" onclick="setLanguage('en')" data-lang="en">EN</a>
        <a class="lang-btn" onclick="setLanguage('zh')" data-lang="zh">中文</a>
    </div>

<div class="card">
    <div class="mode-switch">
        <button class="mode-btn active" onclick="switchMode('slice')" data-i18n="sliceMode">切割模式</button>
        <button class="mode-btn" onclick="switchMode('stitch')" data-i18n="stitchMode">拼接模式</button>
    </div>

    <!-- 切割模式 -->
    <div id="slice-app">
        <div class="control-panel">
            <div class="slider-group">
                <label><span data-i18n="slices">切割份数</span> <span id="s-val">4</span></label>
                <input type="range" id="slices" min="3" max="6" value="4">
            </div>
            <div class="slider-group">
                <label><span data-i18n="gap">模拟 X 间隙 (px)</span> <span id="g-val">16</span></label>
                <input type="range" id="gap" min="0" max="100" value="16">
            </div>
            <div class="slider-group">
                <label><span data-i18n="scale">缩放预处理</span> <span id="scale-val">1.00</span></label>
                <input type="range" id="scale" min="1" max="1.5" step="0.01" value="1">
            </div>
            <div class="slider-group">
                <label><span data-i18n="offset">纵向位移</span> <span id="offset-val">0%</span></label>
                <input type="range" id="offset" min="-50" max="50" step="1" value="0">
            </div>
        </div>

        <div class="upload-zone" id="drop-zone">
            <div id="upload-prompt">
                <p style="font-weight:bold; margin:0;" data-i18n="dragSource">点击或拖入长图</p>
                <p style="font-size:13px; color:#536471; margin:5px 0 0;" data-i18n="dragSourceDesc">自动识别高度并分块</p>
            </div>
            <input type="file" id="file-input" accept="image/*" hidden>
        </div>

        <div id="preview-area">
            <div class="x-mockup">
                <div id="img-container"></div>
            </div>
            <div class="btn-group">
                <button class="btn-main" onclick="downloadAll()" data-i18n="downloadAll">一键下载全部切片</button>
                <button class="btn-outline" onclick="resetApp()" data-i18n="reset">重新上传</button>
            </div>
        </div>
    </div>

    <!-- 拼接模式 -->
    <div id="stitch-app" style="display:none;">
        <div class="control-panel">
            <!-- Template Selection -->
            <div class="slider-group">
                <label><span data-i18n="stitchTemplate">拼接方向</span></label>
                <div style="display: flex; gap: 8px; margin-top: 8px;">
                    <button class="template-btn active" onclick="selectTemplate('vertical')" data-template="vertical">
                        <span data-i18n="templateVertical">⬇️ 纵向</span>
                    </button>
                    <button class="template-btn" onclick="selectTemplate('horizontal')" data-template="horizontal">
                        <span data-i18n="templateHorizontal">➡️ 横向</span>
                    </button>
                </div>
            </div>
            
             <div class="slider-group">
                <label><span data-i18n="stitchGap">填充间隙 (px)</span> <span id="stitch-g-val">0</span></label>
                <input type="range" id="stitch-gap" min="0" max="100" value="0">
            </div>
            
            <!-- X URL 输入 -->
            <div style="margin-top: 15px; border-top: 1px solid #e1e8ed; padding-top: 15px;">
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="x-url" placeholder="粘贴 X 帖子链接 (https://x.com/...)" data-i18n-placeholder="xUrlPlaceholder"
                        style="flex: 1; padding: 8px 12px; border: 1px solid #cfd9de; border-radius: 20px; outline: none;">
                    <button class="btn-main" onclick="fetchFromX()" style="padding: 8px 15px; font-size: 13px; white-space: nowrap;" data-i18n="fetchBtn">获取图片</button>
                </div>
                <div id="fetch-status" style="font-size: 12px; margin-top: 5px; color: #536471; display: none;" data-i18n="fetching">正在获取...</div>
            </div>
        </div>

        <div class="upload-zone" id="stitch-drop-zone">
            <div id="stitch-upload-prompt">
                <p style="font-weight:bold; margin:0;" data-i18n="dragStitch">点击或拖入多张切片</p>
                <p style="font-size:13px; color:#536471; margin:5px 0 0;" data-i18n="dragStitchDesc">文件名排序拼接</p>
            </div>
            <input type="file" id="stitch-file-input" accept="image/*" multiple hidden>
        </div>

        <div id="stitch-preview-area">
            <!-- 排序列表 -->
            <div id="sortable-container" class="sortable-list"></div>

            <div class="x-mockup">
                <div id="stitch-img-container"></div>
            </div>
            <div class="metadata-area" id="metadata-box">
                <label class="metadata-label" data-i18n="metadataLabel">AI 填充元数据 (Gap Metadata)</label>
                <textarea readonly id="metadata-content"></textarea>
            </div>
            <div class="btn-group">
                <button class="btn-main" onclick="downloadStitched()" data-i18n="downloadStitched">下载还原长图</button>
                <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px;">
                    <button class="btn-outline" onclick="reverseStitchImages()" data-i18n="reverseOrder">⇅ 反转顺序</button>
                    <button class="btn-outline" onclick="resetApp()" data-i18n="reset">重新上传</button>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    // i18n Data
    const translations = {
        zh: {
            title: "X 纵向长图切割工具",
            sliceMode: "切割模式",
            stitchMode: "拼接模式",
            slices: "切割份数",
            gap: "模拟 X 间隙 (px)",
            scale: "缩放预处理",
            offset: "纵向位移",
            dragSource: "点击或拖入长图",
            dragSourceDesc: "自动识别高度并分块",
            downloadAll: "一键下载全部切片",
            reset: "重新上传",
            stitchGap: "填充间隙 (px)",
            xUrlPlaceholder: "粘贴 X 帖子链接 (https://x.com/...)",
            fetchBtn: "获取图片",
            fetching: "正在获取...",
            dragStitch: "点击或拖入多张切片",
            dragStitchDesc: "文件名排序拼接",
            downloadStitched: "下载还原长图",
            reverseOrder: "⇅ 反转顺序",
            metadataLabel: "AI 填充元数据 (Gap Metadata)",
            stitchTemplate: "拼接方向",
            templateVertical: "⬇️ 纵向",
            templateHorizontal: "➡️ 横向",
            invalidUrl: "无效的 X 链接",
            noImagesFound: "该推文中未找到图片",
            imagesFound: "找到 {n} 张图片，正在下载...",
            fetchError: "获取失败，请检查链接或稍后重试"
        },
        en: {
            title: "X Long Image Slicer",
            sliceMode: "Slice Mode",
            stitchMode: "Stitch Mode",
            slices: "Slices",
            gap: "Mock Gap (px)",
            scale: "Pre-scale",
            "offset": "Vertical Offset",
            dragSource: "Click or Drop Long Image",
            dragSourceDesc: "Auto-detect height & slice",
            downloadAll: "Download All Slices",
            reset: "Upload New",
            stitchGap: "Fill Gap (px)",
            xUrlPlaceholder: "Paste X Post URL (https://x.com/...)",
            fetchBtn: "Fetch Images",
            fetching: "Fetching...",
            dragStitch: "Click or Drop Slices",
            dragStitchDesc: "Stitch by filename order",
            downloadStitched: "Download Long Image",
            reverseOrder: "⇅ Reverse Order",
            metadataLabel: "Gap Metadata",
            stitchTemplate: "Stitch Direction",
            templateVertical: "⬇️ Vertical",
            templateHorizontal: "➡️ Horizontal",
            invalidUrl: "Invalid X URL",
            noImagesFound: "No images found in this tweet",
            imagesFound: "Found {n} images, downloading...",
            fetchError: "Fetch failed, check URL or try again"
        }
    };

    let currentLang = navigator.language.startsWith('zh') ? 'zh' : 'en';

    function setLanguage(lang) {
        if (!translations[lang]) return;
        currentLang = lang;
        const t = translations[lang];

        // Update Text
        document.querySelectorAll('[data-i18n]').forEach(el => {
            const key = el.getAttribute('data-i18n');
            if (t[key]) el.innerText = t[key];
        });

        // Update Placeholders
        document.querySelectorAll('[data-i18n-placeholder]').forEach(el => {
            const key = el.getAttribute('data-i18n-placeholder');
            if (t[key]) el.placeholder = t[key];
        });

        // Update Title
        document.title = t.title;

        // Update html lang
        document.documentElement.lang = lang;

        // Update Button States
        document.querySelectorAll('.lang-btn').forEach(btn => {
            btn.classList.toggle('active', btn.getAttribute('data-lang') === lang);
        });

        // Save Preference
        localStorage.setItem('x-slice-lang', lang);
    }

    // Helper to get translation string in JS
    function t(key, params = {}) {
        let str = translations[currentLang][key] || key;
        for (const k in params) {
            str = str.replace(`{${k}}`, params[k]);
        }
        return str;
    }

    // Initialize Language
    const savedLang = localStorage.getItem('x-slice-lang');
    setLanguage(savedLang || currentLang);

    // 模式切换
    function switchMode(mode) {
        document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
        if (mode === 'slice') {
            document.querySelector('.mode-btn:nth-child(1)').classList.add('active');
            document.getElementById('slice-app').style.display = 'block';
            document.getElementById('stitch-app').style.display = 'none';
        } else {
            document.querySelector('.mode-btn:nth-child(2)').classList.add('active');
            document.getElementById('slice-app').style.display = 'none';
            document.getElementById('stitch-app').style.display = 'block';
        }
    }

    function resetApp() {
        if (document.getElementById('slice-app').style.display !== 'none') {
            // 切割模式重置
            sourceImg = null;
            fileInput.value = '';
            dropZone.style.display = 'block';
            previewArea.style.display = 'none';
        } else {
            // 拼接模式重置
            stitchImages = [];
            stitchFileInput.value = '';
            stitchDropZone.style.display = 'block';
            stitchPreviewArea.style.display = 'none';
            document.getElementById('metadata-box').style.display = 'none';
            stitchImgContainer.innerHTML = '';
        }
    }

    // --- 切割模式逻辑 ---
    const fileInput = document.getElementById('file-input');
    const dropZone = document.getElementById('drop-zone');
    const slicesInput = document.getElementById('slices');
    const gapInput = document.getElementById('gap');
    const scaleInput = document.getElementById('scale');
    const offsetInput = document.getElementById('offset');
    const imgContainer = document.getElementById('img-container');
    const previewArea = document.getElementById('preview-area');

    let sourceImg = null;

    // 仅更新 UI 数值显示（轻量操作，绑定到 input 事件）
    function updateUI() {
        document.getElementById('s-val').innerText = slicesInput.value;
        document.getElementById('g-val').innerText = gapInput.value + 'px';
        document.getElementById('scale-val').innerText = parseFloat(scaleInput.value).toFixed(2);
        document.getElementById('offset-val').innerText = offsetInput.value + '%';
        render();
    }

    // 核心渲染函数（重操作，绑定到 change 事件）
    function render() {
        if (!sourceImg) return;
        
        const n = parseInt(slicesInput.value);
        const visualGap = parseInt(gapInput.value); 
        const userScale = parseFloat(scaleInput.value);
        const userOffsetPct = parseInt(offsetInput.value) / 100;
        
        const previewWidth = imgContainer.offsetWidth == 0 ? dropZone.offsetWidth : imgContainer.offsetWidth;
        const sourceGap = visualGap * (sourceImg.width / previewWidth);
        const sliceH = (sourceImg.height - (sourceGap * (n - 1))) / n;
        
        imgContainer.style.gap = visualGap + 'px';

        // DOM 重用优化：只有当切片数量变化时才重建 DOM，防止调整参数时页面闪烁或回滚
        const existingImgs = imgContainer.querySelectorAll('img');
        if (existingImgs.length !== n) {
            imgContainer.innerHTML = '';
            for (let k = 0; k < n; k++) {
                imgContainer.appendChild(document.createElement('img'));
            }
        }
        const targetImgs = imgContainer.querySelectorAll('img');

        const MAX_PREVIEW_WIDTH = 800;
        const previewScale = sourceImg.width > MAX_PREVIEW_WIDTH ? MAX_PREVIEW_WIDTH / sourceImg.width : 1;
        const canvasW = sourceImg.width * previewScale;
        const canvasH = sliceH * previewScale;
        const offsetPx = userOffsetPct * sourceImg.height;

        for (let i = 0; i < n; i++) {
            const canvas = document.createElement('canvas');
            canvas.width = canvasW;
            canvas.height = canvasH;
            const ctx = canvas.getContext('2d');
            
            const sy = i * (sliceH + sourceGap);
            
            ctx.save();
            // 视口变换
            ctx.translate(0, -sy * previewScale);
            
            // 中心变换
            const cx = (sourceImg.width * previewScale) / 2;
            const cy = (sourceImg.height * previewScale) / 2;
            ctx.translate(cx, cy);
            
            // 用户变换
            ctx.scale(userScale, userScale);
            ctx.translate(0, offsetPx * previewScale);

            // 绘制
            ctx.drawImage(sourceImg, 
                -sourceImg.width * previewScale / 2, 
                -sourceImg.height * previewScale / 2, 
                sourceImg.width * previewScale, 
                sourceImg.height * previewScale
            );
            ctx.restore();
            
            targetImgs[i].src = canvas.toDataURL('image/png');
        }
        previewArea.style.display = 'block';
        dropZone.style.display = 'none';
        window.currentSourceGap = sourceGap;
    }

    // 下载逻辑：重新生成原画质切片并下载
    function downloadAll() {
        if (!sourceImg || window.currentSourceGap === undefined) return;
        
        const n = parseInt(slicesInput.value);
        const sourceGap = window.currentSourceGap;
        const sliceH = (sourceImg.height - (sourceGap * (n - 1))) / n;
        const userScale = parseFloat(scaleInput.value);
        const userOffsetPct = parseInt(offsetInput.value) / 100;
        const offsetPx = userOffsetPct * sourceImg.height;

        const canvas = document.createElement('canvas');
        canvas.width = sourceImg.width;
        canvas.height = sliceH;
        const ctx = canvas.getContext('2d');

        for (let i = 0; i < n; i++) {
            setTimeout(() => {
                const sy = i * (sliceH + sourceGap);
                ctx.clearRect(0, 0, canvas.width, canvas.height); // 清空画布
                
                ctx.save();
                ctx.translate(0, -sy);
                
                const cx = sourceImg.width / 2;
                const cy = sourceImg.height / 2;
                ctx.translate(cx, cy);
                
                ctx.scale(userScale, userScale);
                ctx.translate(0, offsetPx);

                ctx.drawImage(sourceImg, -sourceImg.width/2, -sourceImg.height/2);
                ctx.restore();
                
                const a = document.createElement('a');
                a.href = canvas.toDataURL('image/png');
                a.download = `X_Split_${i+1}.png`;
                a.click();
            }, i * 300);
        }
    }

    // 文件监听
    fileInput.onchange = e => {
        if (e.target.files && e.target.files[0]) {
            handleFile(e.target.files[0]);
        }
    };

    // 处理文件上传
    const handleFile = (file) => {
        if (!file || !file.type.startsWith('image/')) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            sourceImg = new Image();
            sourceImg.onload = render;
            sourceImg.src = e.target.result;
        };
        reader.readAsDataURL(file);
    };

    dropZone.onclick = () => fileInput.click();
    dropZone.ondragover = (e) => { e.preventDefault(); dropZone.style.background = "#e8f5fe"; };
    dropZone.ondragleave = () => { dropZone.style.background = ""; };
    dropZone.ondrop = (e) => {
        e.preventDefault();
        dropZone.style.background = "";
        handleFile(e.dataTransfer.files[0]);
    };
    
    // 性能优化：拖动时只更新数值，松手时才渲染图片
    slicesInput.oninput = updateUI;
    gapInput.oninput = updateUI;
    scaleInput.oninput = updateUI;
    offsetInput.oninput = updateUI;
    
    // 初始化 UI 状态
    updateUI();
    
    // URL 参数检查：如果包含 ?mode=stitch，自动进入拼接模式
    // 示例：index.html?mode=stitch
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.get('mode') === 'stitch') {
        switchMode('stitch');
    }

    // --- 拼接模式逻辑 ---
    const stitchFileInput = document.getElementById('stitch-file-input');
    const stitchDropZone = document.getElementById('stitch-drop-zone');
    const stitchGapInput = document.getElementById('stitch-gap');
    const stitchImgContainer = document.getElementById('stitch-img-container');
    const stitchPreviewArea = document.getElementById('stitch-preview-area');
    const sortableContainer = document.getElementById('sortable-container');
    const metadataBox = document.getElementById('metadata-content');
    const xUrlInput = document.getElementById('x-url');
    const fetchStatus = document.getElementById('fetch-status');
    
    let stitchImages = []; // Array of Image objects
    let dragStartIndex;
    let touchDragItem = null; // 用于移动端拖拽
    let currentTemplate = 'vertical'; // Default template
    
    // 模板选择
    function selectTemplate(template) {
        currentTemplate = template;
        document.querySelectorAll('.template-btn').forEach(btn => {
            btn.classList.toggle('active', btn.getAttribute('data-template') === template);
        });
        renderStitch(false); // Re-render preview without rebuilding sortable list
    }
    
    // 监听 Gap 变化
    stitchGapInput.oninput = () => {
        document.getElementById('stitch-g-val').innerText = stitchGapInput.value + 'px';
        renderStitch(false); // UI update doesn't need to rebuild list
    }

    // 从 X 获取图片逻辑
    async function fetchFromX() {
        const url = xUrlInput.value.trim();
        if (!url) return;
        // ... (unchanged part valid, but logic flow continues)
        // Replicating full logic for context if needed, but here just updating usages of renderStitch
        
        // 提取 Tweet ID
        const match = url.match(/(?:twitter|x)\.com\/\w+\/status\/(\d+)/);
        if (!match) {
            showStatus(t('invalidUrl'), true);
            return;
        }
        const tweetId = match[1];

        showStatus(t('fetching'), false);

        try {
            const response = await fetch(`https://api.fxtwitter.com/status/${tweetId}`);
            if (!response.ok) throw new Error('API 请求失败');
            
            const data = await response.json();
            
            if (!data.tweet || !data.tweet.media || !data.tweet.media.photos || data.tweet.media.photos.length === 0) {
                showStatus(t('noImagesFound'), true);
                return;
            }

            const photos = data.tweet.media.photos;
            showStatus(t('imagesFound', {n: photos.length}), false);

            const imagePromises = photos.map(photo => {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    const proxyUrl = `https://wsrv.nl/?url=${encodeURIComponent(photo.url)}`;
                    img.onload = () => resolve(img);
                    img.onerror = () => reject(new Error('图片加载失败'));
                    img.src = proxyUrl;
                });
            });

            const loadedImages = await Promise.all(imagePromises);
            // 默认反转，因为推文通常最后一张在上面? 或者用户习惯? 
            // 之前的逻辑是 loadedImages.reverse()。
            stitchImages = loadedImages.reverse();
            
            if (stitchImages.length > 0) {
                showStatus('', false);
                renderSortableList(); // Show list
                renderStitch();      // Show preview
            }

        } catch (err) {
            console.error(err);
            showStatus(t('fetchError'), true);
        }
    }

    function showStatus(msg, isError) {
        fetchStatus.style.display = msg ? 'block' : 'none';
        fetchStatus.style.color = isError ? '#e0245e' : '#536471';
        fetchStatus.innerText = msg;
    }

    stitchFileInput.onchange = e => {
        if (e.target.files && e.target.files.length > 0) {
            handleStitchFiles(e.target.files);
        }
    };

    stitchDropZone.onclick = () => stitchFileInput.click();
    stitchDropZone.ondragover = (e) => { e.preventDefault(); stitchDropZone.style.background = "#e8f5fe"; };
    stitchDropZone.ondragleave = () => { stitchDropZone.style.background = ""; };
    stitchDropZone.ondrop = (e) => {
        e.preventDefault();
        stitchDropZone.style.background = "";
        if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
            handleStitchFiles(e.dataTransfer.files);
        }
    };

    function handleStitchFiles(files) {
        // 按文件名排序
        const sortedFiles = Array.from(files).sort((a, b) => a.name.localeCompare(b.name, undefined, {numeric: true, sensitivity: 'base'}));
        
        Promise.all(sortedFiles.map(file => {
            return new Promise((resolve) => {
                if (!file.type.startsWith('image/')) resolve(null);
                const img = new Image();
                img.onload = () => resolve(img);
                img.src = URL.createObjectURL(file);
            });
        })).then(images => {
            stitchImages = images.filter(img => img !== null);
            if(stitchImages.length > 0) {
                renderSortableList();
                renderStitch();
            }
        });
    }

    // 构建可排序列表
    function renderSortableList() {
        sortableContainer.innerHTML = '';
        stitchImages.forEach((img, index) => {
            const item = document.createElement('div');
            item.className = 'sortable-item';
            item.draggable = true;
            item.dataset.index = index;
            
            // 尝试获取文件名（仅本地上传有），或是 URL
            const name = img.src.length > 50 ? `Image ${index + 1}` : img.src.split('/').pop();
            
            item.innerHTML = `
                <div class="sortable-icon">≡</div>
                <img src="${img.src}">
                <span>${name}</span>
            `;
            
            addDragEvents(item);
            sortableContainer.appendChild(item);
        });
    }

    function addDragEvents(item) {
        // Desktop Drag Events
        item.addEventListener('dragstart', function() {
            dragStartIndex = +this.dataset.index;
            this.classList.add('dragging');
        });

        item.addEventListener('dragover', function(e) {
            e.preventDefault();
        });

        item.addEventListener('drop', function() {
            const dragEndIndex = +this.dataset.index;
            swapItems(dragStartIndex, dragEndIndex);
            this.classList.remove('dragging');
        });

        item.addEventListener('dragenter', function() {
            this.style.borderColor = '#1da1f2';
        });

        item.addEventListener('dragleave', function() {
            this.style.borderColor = '#e1e8ed';
        });
        
        item.addEventListener('dragend', function() {
            this.classList.remove('dragging');
            document.querySelectorAll('.sortable-item').forEach(i => i.style.borderColor = '#e1e8ed');
        });

        // Touch Drag Events (Mobile)
        // 绑定在图标上以避免影响列表滚动
        const handle = item.querySelector('.sortable-icon');
        
        handle.addEventListener('touchstart', function(e) {
            e.preventDefault(); // 阻止默认滚动
            touchDragItem = item;
            item.classList.add('touch-dragging');
        }, {passive: false});

        handle.addEventListener('touchmove', function(e) {
            e.preventDefault(); 
            if (!touchDragItem) return;

            const touch = e.touches[0];
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            const targetItem = target ? target.closest('.sortable-item') : null;

            // 清除旧的高亮
            document.querySelectorAll('.sortable-item').forEach(i => i.classList.remove('touch-target'));

            if (targetItem && targetItem !== touchDragItem) {
                targetItem.classList.add('touch-target');
            }
        }, {passive: false});

        handle.addEventListener('touchend', function(e) {
            if (!touchDragItem) return;
            
            item.classList.remove('touch-dragging');
            
            const touch = e.changedTouches[0];
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            const targetItem = target ? target.closest('.sortable-item') : null;
            
            // 清理高亮
            document.querySelectorAll('.sortable-item').forEach(i => i.classList.remove('touch-target'));

            if (targetItem && targetItem !== item) {
                const fromIndex = +item.dataset.index;
                const toIndex = +targetItem.dataset.index;
                swapItems(fromIndex, toIndex);
            }
            touchDragItem = null;
        });
    }
    
    function swapItems(fromIndex, toIndex) {
        if (fromIndex === undefined || toIndex === undefined || fromIndex === toIndex) return;
        
        const itemMoved = stitchImages[fromIndex];
        stitchImages.splice(fromIndex, 1);
        stitchImages.splice(toIndex, 0, itemMoved);
        
        renderSortableList();
        renderStitch();
    }

    function renderStitch(rebuildList = false) {
        if (stitchImages.length === 0) return;
        if (rebuildList) renderSortableList();
        
        stitchDropZone.style.display = 'none';
        stitchPreviewArea.style.display = 'block';
        stitchImgContainer.innerHTML = ''; 

        const gap = parseInt(stitchGapInput.value);
        let metadata = [];
        
        if (currentTemplate === 'vertical') {
            // Vertical stitching (original logic)
            const baseWidth = stitchImages[0].width;
            let totalHeight = 0;
            
            // 计算总高度
            stitchImages.forEach((img, idx) => {
                const h = img.height * (baseWidth / img.width);
                totalHeight += h;
                if (gap > 0 && idx < stitchImages.length - 1) {
                    totalHeight += gap;
                }
            });
            
            const canvas = document.createElement('canvas');
            canvas.width = baseWidth;
            canvas.height = totalHeight;
            const ctx = canvas.getContext('2d');
            
            let currentY = 0;
            
            stitchImages.forEach((img, idx) => {
                const h = img.height * (baseWidth / img.width);
                ctx.drawImage(img, 0, currentY, baseWidth, h);
                currentY += h;
                
                if (gap > 0 && idx < stitchImages.length - 1) {
                    drawMosaic(ctx, 0, currentY, baseWidth, gap);
                    
                    metadata.push({
                        index: idx,
                        y: currentY,
                        height: gap,
                        width: baseWidth
                    });
                    
                    currentY += gap;
                }
            });
            
            const resultImg = document.createElement('img');
            resultImg.src = canvas.toDataURL('image/png');
            resultImg.style.width = '100%'; 
            stitchImgContainer.appendChild(resultImg);
        } else {
            // Horizontal stitching (new logic)
            const baseHeight = stitchImages[0].height;
            let totalWidth = 0;
            
            // 计算总宽度
            stitchImages.forEach((img, idx) => {
                const w = img.width * (baseHeight / img.height);
                totalWidth += w;
                if (gap > 0 && idx < stitchImages.length - 1) {
                    totalWidth += gap;
                }
            });
            
            const canvas = document.createElement('canvas');
            canvas.width = totalWidth;
            canvas.height = baseHeight;
            const ctx = canvas.getContext('2d');
            
            let currentX = 0;
            
            stitchImages.forEach((img, idx) => {
                const w = img.width * (baseHeight / img.height);
                ctx.drawImage(img, currentX, 0, w, baseHeight);
                currentX += w;
                
                if (gap > 0 && idx < stitchImages.length - 1) {
                    drawMosaic(ctx, currentX, 0, gap, baseHeight);
                    
                    metadata.push({
                        index: idx,
                        x: currentX,
                        width: gap,
                        height: baseHeight
                    });
                    
                    currentX += gap;
                }
            });
            
            const resultImg = document.createElement('img');
            resultImg.src = canvas.toDataURL('image/png');
            resultImg.style.width = '100%'; 
            stitchImgContainer.appendChild(resultImg);
        }
        
        if (gap > 0) {
             document.getElementById('metadata-box').style.display = 'block';
             metadataBox.value = JSON.stringify(metadata, null, 2);
        } else {
             document.getElementById('metadata-box').style.display = 'none';
        }
    }
    
    function drawMosaic(ctx, x, y, width, height, size = 16) {
        for(let py = y; py < y + height; py += size) {
            for(let px = x; px < x + width; px += size) {
                const gray = Math.floor(Math.random() * 50 + 200); 
                ctx.fillStyle = `rgb(${gray},${gray},${gray})`;
                const w = Math.min(size, x + width - px);
                const h = Math.min(size, y + height - py);
                ctx.fillRect(px, py, w, h);
            }
        }
    }
    
    function downloadStitched() {
         const img = stitchImgContainer.querySelector('img');
         if(img) {
             const link = document.createElement('a');
             link.download = 'X_Stitched.png';
             link.href = img.src;
             link.click();
         }
    }
    
    // 反转图片顺序（手动修正）
    function reverseStitchImages() {
        if (!stitchImages || stitchImages.length === 0) return;
        stitchImages.reverse();
        renderSortableList();
        renderStitch();
    }

</script>
</body>
</html>