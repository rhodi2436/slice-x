<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>X 纵向长图切割工具</title>
    <style>
        :root {
            --x-blue: #1da1f2;
            --x-dark: #15202b;
            --bg: #f7f9f9;
        }
        body { font-family: -apple-system, system-ui, sans-serif; background: var(--bg); display: flex; justify-content: center; padding: 40px 20px; }
        .card { background: white; width: 100%; max-width: 500px; padding: 25px; border-radius: 20px; box-shadow: 0 10px 30px rgba(0,0,0,0.05); }
        h2 { margin-top: 0; color: #0f1419; font-size: 20px; text-align: center; }
        
        /* 控制区 */
        .control-panel { background: #f0f3f4; padding: 15px; border-radius: 12px; margin-bottom: 20px; }
        .slider-group { margin-bottom: 15px; }
        .slider-group label { display: flex; justify-content: space-between; font-size: 14px; margin-bottom: 5px; color: #536471; }
        input[type="range"] { width: 100%; accent-color: var(--x-blue); }

        /* 上传区 */
        .upload-zone { border: 2px dashed #cfd9de; border-radius: 12px; padding: 40px 20px; text-align: center; cursor: pointer; transition: 0.2s; }
        .upload-zone:hover { background: #e8f5fe; border-color: var(--x-blue); }
        
        /* 预览区 */
        #preview-area { display: none; margin-top: 20px; }
        .x-mockup { background: var(--x-dark); padding: 15px; border-radius: 12px; display: flex; flex-direction: column; align-items: center; }
        #img-container { width: 100%; display: flex; flex-direction: column; }
        #img-container img { width: 100%; border-radius: 4px; }
        
        /* 按钮 */
        .btn-group { margin-top: 20px; display: grid; gap: 10px; }
        button { padding: 12px; border: none; border-radius: 25px; font-weight: bold; cursor: pointer; transition: 0.2s; font-size: 15px; }
        .btn-main { background: var(--x-blue); color: white; }
        .btn-main:hover { background: #1a91da; }
        .btn-outline { background: #eff3f4; color: #0f1419; }
    </style>
</head>
<body>

<div class="card">
    <h2>X 纵向长图切割器</h2>
    
    <div class="control-panel">
        <div class="slider-group">
            <label>切割份数 <span id="s-val">4</span></label>
            <input type="range" id="slices" min="3" max="6" value="4">
        </div>
        <div class="slider-group">
            <label>模拟 X 间隙 (px) <span id="g-val">16</span></label>
            <input type="range" id="gap" min="0" max="100" value="16">
        </div>
        <div class="slider-group">
            <label>缩放预处理 <span id="scale-val">1.00</span></label>
            <input type="range" id="scale" min="1" max="1.5" step="0.01" value="1">
        </div>
        <div class="slider-group">
            <label>纵向位移 <span id="offset-val">0%</span></label>
            <input type="range" id="offset" min="-50" max="50" step="1" value="0">
        </div>
    </div>

    <div class="upload-zone" id="drop-zone">
        <div id="upload-prompt">
            <p style="font-weight:bold; margin:0;">点击或拖入长图</p>
            <p style="font-size:13px; color:#536471; margin:5px 0 0;">自动识别高度并分块</p>
        </div>
        <input type="file" id="file-input" accept="image/*" hidden>
    </div>

    <div id="preview-area">
        <div class="x-mockup">
            <div id="img-container"></div>
        </div>
        <div class="btn-group">
            <button class="btn-main" onclick="downloadAll()">一键下载全部切片</button>
            <button class="btn-outline" onclick="location.reload()">重新上传</button>
        </div>
    </div>
</div>

<script>
    const fileInput = document.getElementById('file-input');
    const dropZone = document.getElementById('drop-zone');
    const slicesInput = document.getElementById('slices');
    const gapInput = document.getElementById('gap');
    const scaleInput = document.getElementById('scale');
    const offsetInput = document.getElementById('offset');
    const imgContainer = document.getElementById('img-container');
    const previewArea = document.getElementById('preview-area');

    let sourceImg = null;

    // 仅更新 UI 数值显示（轻量操作，绑定到 input 事件）
    function updateUI() {
        document.getElementById('s-val').innerText = slicesInput.value;
        document.getElementById('g-val').innerText = gapInput.value + 'px';
        document.getElementById('scale-val').innerText = parseFloat(scaleInput.value).toFixed(2);
        document.getElementById('offset-val').innerText = offsetInput.value + '%';
        render();
    }

    // 核心渲染函数（重操作，绑定到 change 事件）
    function render() {
        if (!sourceImg) return;
        
        const n = parseInt(slicesInput.value);
        const visualGap = parseInt(gapInput.value); 
        const userScale = parseFloat(scaleInput.value);
        const userOffsetPct = parseInt(offsetInput.value) / 100;
        
        const previewWidth = imgContainer.offsetWidth == 0 ? dropZone.offsetWidth : imgContainer.offsetWidth;
        const sourceGap = visualGap * (sourceImg.width / previewWidth);
        const sliceH = (sourceImg.height - (sourceGap * (n - 1))) / n;
        
        imgContainer.style.gap = visualGap + 'px';

        // DOM 重用优化：只有当切片数量变化时才重建 DOM，防止调整参数时页面闪烁或回滚
        const existingImgs = imgContainer.querySelectorAll('img');
        if (existingImgs.length !== n) {
            imgContainer.innerHTML = '';
            for (let k = 0; k < n; k++) {
                imgContainer.appendChild(document.createElement('img'));
            }
        }
        const targetImgs = imgContainer.querySelectorAll('img');

        const MAX_PREVIEW_WIDTH = 800;
        const previewScale = sourceImg.width > MAX_PREVIEW_WIDTH ? MAX_PREVIEW_WIDTH / sourceImg.width : 1;
        const canvasW = sourceImg.width * previewScale;
        const canvasH = sliceH * previewScale;
        const offsetPx = userOffsetPct * sourceImg.height;

        for (let i = 0; i < n; i++) {
            const canvas = document.createElement('canvas');
            canvas.width = canvasW;
            canvas.height = canvasH;
            const ctx = canvas.getContext('2d');
            
            const sy = i * (sliceH + sourceGap);
            
            ctx.save();
            // 视口变换
            ctx.translate(0, -sy * previewScale);
            
            // 中心变换
            const cx = (sourceImg.width * previewScale) / 2;
            const cy = (sourceImg.height * previewScale) / 2;
            ctx.translate(cx, cy);
            
            // 用户变换
            ctx.scale(userScale, userScale);
            ctx.translate(0, offsetPx * previewScale);

            // 绘制
            ctx.drawImage(sourceImg, 
                -sourceImg.width * previewScale / 2, 
                -sourceImg.height * previewScale / 2, 
                sourceImg.width * previewScale, 
                sourceImg.height * previewScale
            );
            ctx.restore();
            
            targetImgs[i].src = canvas.toDataURL('image/png');
        }
        previewArea.style.display = 'block';
        dropZone.style.display = 'none';
        window.currentSourceGap = sourceGap;
    }

    // 下载逻辑：重新生成原画质切片并下载
    function downloadAll() {
        if (!sourceImg || window.currentSourceGap === undefined) return;
        
        const n = parseInt(slicesInput.value);
        const sourceGap = window.currentSourceGap;
        const sliceH = (sourceImg.height - (sourceGap * (n - 1))) / n;
        const userScale = parseFloat(scaleInput.value);
        const userOffsetPct = parseInt(offsetInput.value) / 100;
        const offsetPx = userOffsetPct * sourceImg.height;

        const canvas = document.createElement('canvas');
        canvas.width = sourceImg.width;
        canvas.height = sliceH;
        const ctx = canvas.getContext('2d');

        for (let i = 0; i < n; i++) {
            setTimeout(() => {
                const sy = i * (sliceH + sourceGap);
                ctx.clearRect(0, 0, canvas.width, canvas.height); // 清空画布
                
                ctx.save();
                ctx.translate(0, -sy);
                
                const cx = sourceImg.width / 2;
                const cy = sourceImg.height / 2;
                ctx.translate(cx, cy);
                
                ctx.scale(userScale, userScale);
                ctx.translate(0, offsetPx);

                ctx.drawImage(sourceImg, -sourceImg.width/2, -sourceImg.height/2);
                ctx.restore();
                
                const a = document.createElement('a');
                a.href = canvas.toDataURL('image/png');
                a.download = `X_Split_${i+1}.png`;
                a.click();
            }, i * 300);
        }
    }

    // 文件监听
    fileInput.onchange = e => {
        if (e.target.files && e.target.files[0]) {
            handleFile(e.target.files[0]);
        }
    };

    // 处理文件上传
    const handleFile = (file) => {
        if (!file || !file.type.startsWith('image/')) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            sourceImg = new Image();
            sourceImg.onload = render;
            sourceImg.src = e.target.result;
        };
        reader.readAsDataURL(file);
    };

    dropZone.onclick = () => fileInput.click();
    dropZone.ondragover = (e) => { e.preventDefault(); dropZone.style.background = "#e8f5fe"; };
    dropZone.ondragleave = () => { dropZone.style.background = ""; };
    dropZone.ondrop = (e) => {
        e.preventDefault();
        dropZone.style.background = "";
        handleFile(e.dataTransfer.files[0]);
    };
    
    // 性能优化：拖动时只更新数值，松手时才渲染图片
    slicesInput.oninput = updateUI;
    gapInput.oninput = updateUI;
    scaleInput.oninput = updateUI;
    offsetInput.oninput = updateUI;
    
    // 初始化 UI 状态
    updateUI();
</script>
</body>
</html>